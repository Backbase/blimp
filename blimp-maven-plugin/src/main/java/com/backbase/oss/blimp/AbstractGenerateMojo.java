package com.backbase.oss.blimp;

import static java.lang.String.format;
import static java.util.Arrays.asList;
import static java.util.Arrays.stream;

import com.backbase.oss.blimp.LiquibaseUpdate.LiquibaseUpdateBuilder;
import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.FileTime;
import java.util.List;
import java.util.stream.Stream;
import liquibase.configuration.LiquibaseConfiguration;
import liquibase.configuration.SystemPropertyProvider;
import liquibase.resource.FileSystemResourceAccessor;
import lombok.SneakyThrows;
import org.apache.maven.artifact.DependencyResolutionRequiredException;
import org.apache.maven.model.Resource;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Parameter;
import org.codehaus.plexus.util.Scanner;

public abstract class AbstractGenerateMojo extends MojoBase {

    /**
     * The location of the <i>changelog</i> to execute.
     * <p>
     * Usually a file name relative to the input directory but it can also point to a classpath
     * resource.
     * </p>
     */
    @Parameter(property = "blimp.changeLogFile", defaultValue = "db.changelog-persistence.xml", required = true)
    private String changeLogFile;

    /**
     * List of glob patterns specifing the changelog files.
     * <p>
     * Not needed by Liquibase, but used by the plugin to avoid unnecessary executions of the goal.
     * </p>
     */
    @Parameter(property = "blimp.inputPatterns",
        defaultValue = "**/*.sql,**/db.changelog*.xml,**/db.changelog*.yml",
        required = true)
    private String[] inputPatterns;

    /**
     * Specifies how to generate the name of SQL script.
     * <p>
     * The following placeholders are available:
     * <ul>
     * <li>database: the database type</li>
     * <li>group: the name of the group for which the goal generates the SQL script.</li>
     * <li>service: the service name taken from the {@link MojoBase#serviceName}.</li>
     * </p>
     * For full creation SQL scripts, the group name is set as {@code create}.
     */
    @Parameter(property = "blimp.sqlFileNameFormat", defaultValue = "@{database}/@{group}/@{service}.sql")
    private String sqlFileNameFormat;

    /**
     * The file encoding used for SQL files.
     */
    @Parameter(property = "blimp.encoding", defaultValue = "UTF-8")
    private String encoding;

    /**
     * The list of the databases for which to generate the SQL scripts.
     */
    @Parameter(property = "blimp.databases", defaultValue = "mysql", required = true)
    private List<String> databases;

    /**
     * Whether to add the SQL scripts as a test resource of the project.
     */
    @Parameter(property = "blimp.addTestResource", defaultValue = "false")
    protected boolean addTestResource;

    /**
     * Generates an update script even though there is only one group in changelog.
     * <p>
     * When only on group is found by {@link #groupingStrategy} configuration, the creation script and
     * the update script are identical. In this case the update script is not generated by default.
     * </p>
     */
    @Parameter(property = "blimp.forceUpdateScript", defaultValue = "false")
    private boolean forceUpdateScript;

    /**
     * Specifies a map of properties you want to pass to Liquibase.
     */
    @Parameter(property = "blimp.properties")
    private MavenPropertiesProvider properties;

    /**
     * Controls how to group the changesets to generate one SQL script for a given context or label.
     * <p>
     * The following options are available
     * <ul>
     * <li><b>CONTEXTS</b>: use the changeset context to group changes.
     * <li><b>LABELS</b>: use the changeset label to group changes.
     * <li><b>AUTO</b>: tries to identify if the changes use contexts or labels; if both are present,
     * then contexts is preferred.
     * </ul>
     * Note that when a context or label contains multiple values, only the first one is considered.
     * </p>
     */
    @Parameter(property = "blimp.groupingStrategy", defaultValue = "AUTO")
    private ScriptGroupingStrategy groupingStrategy;

    /**
     * The location of the test cache directory where Liquibase stores the CSV file use to generate the
     * upgrade scripts.
     */
    @Parameter(property = "blimp.testCacheDirectory",
        defaultValue = "${project.build.directory}/blimp-cache",
        required = true, readonly = true)
    private File cacheDirectory;

    @Override
    protected void doExecute() throws MojoExecutionException, MojoFailureException {
        final LiquibaseUpdate update = evaluateChanges();

        if (update == null) {
            return;
        }

        processSystemProperties();
        generateSQL(update);
    }

    private LiquibaseUpdate evaluateChanges() throws MojoExecutionException {
        if (this.databases.isEmpty()) {
            getLog().info("SQL generation skipped, no database specified.");

            return null;
        }

        final LiquibaseUpdateBuilder builder = LiquibaseUpdate.builder()
            .changeLogFile(this.changeLogFile)
            .strategy(this.groupingStrategy)
            .writerProvider(this::createWriter);

        final String[] inputs;

        if (getChangeLogDirectory().exists()) {
            final Scanner scanner = this.buildContext.newScanner(getChangeLogDirectory());
            scanner.setIncludes(
                Stream.concat(
                    Stream.of(this.changeLogFile), stream(this.inputPatterns))
                    .toArray(String[]::new));
            scanner.scan();
            inputs = scanner.getIncludedFiles();
        } else {
            inputs = null;
        }

        if (inputs != null && inputs.length > 0) {
            builder.accessor(new FileSystemResourceAccessor(getChangeLogDirectory().getPath()));
        } else {
            builder.classLoader(classLoader());
        }

        final LiquibaseUpdate update = builder.strategy(this.groupingStrategy).build();

        if (update.groups().isEmpty()) {
            getLog().info("SQL generation skipped, no change found");

            return null;
        }

        addOutputResource();

        return update;
    }

    protected abstract void addOutputResource();

    protected abstract File getChangeLogDirectory();

    private void processSystemProperties() {
        if (this.properties != null) {
            LiquibaseConfiguration.getInstance().init(new SystemPropertyProvider(), this.properties);
        }
    }

    private void generateSQL(LiquibaseUpdate changes) throws MojoExecutionException {
        for (final String database : this.databases) {
            final LiquibaseUpdate create = changes.newBuilder().database(database).build();
            final File marker = cacheFile(database + "-" + create.digest());
            final File createCSV = cacheFile(database + "-create.csv");

            if (this.buildContext.isUptodate(createCSV, marker)) {
                continue;
            }

            try (Writer out = createWriter(marker.toPath())) {
            } catch (final IOException e) {
                throw new MojoExecutionException(database, e);
            }

            create.newBuilder()
                .changeLogCache(createCSV.toPath())
                .output(sqlFileName(database, "create"))
                .build()
                .renameCache()
                .generateSQL();

            if (create.groups().size() < 2 && !this.forceUpdateScript) {
                continue;
            }

            final File updateCSV = cacheFile(marker.getName() + "-update.csv");

            final LiquibaseUpdate update = create.newBuilder()
                .changeLogCache(updateCSV.toPath())
                .build()
                .renameCache();

            for (final String name : create.groups()) {
                update.newBuilder()
                    .select(name)
                    .output(sqlFileName(database, name))
                    .build()
                    .generateSQL();
            }
        }

    }

    private ClassLoader classLoader() throws MojoExecutionException {
        try {
            final List<String> classpath = classpathElements();

            final URL[] urls = Stream.concat(classpath.stream()
                // Exclude hibernate-core from Liquibase classpath
                // which would activate the formatter that may conflict
                // with other Liquibase extensions.
                // The formatter is only activated when Hibernate
                // is explicitly set as dependency of the plugin
                .filter(item -> !item.contains("hibernate-core"))
                .map(Paths::get)
                .map(Path::toUri)
                .map(this::toURL),
                Stream.of(getChangeLogDirectory().toURI().toURL()))
                .toArray(URL[]::new);

            return new URLClassLoader(urls, getClass().getClassLoader());
        } catch (final DependencyResolutionRequiredException | MalformedURLException e) {
            throw new MojoExecutionException("Cannot construct Liquibase classpath", e);
        }

    }

    protected abstract List<String> classpathElements() throws DependencyResolutionRequiredException;

    protected Resource createResource() {
        final Resource resource = new Resource();

        resource.setDirectory(getScriptsDirectory().getPath());
        resource.setIncludes(asList(SQL_FILES));

        return resource;
    }

    @SneakyThrows
    private URL toURL(URI uri) {
        return uri.toURL();
    }

    @SneakyThrows
    private FileTime fileTime(Path path) {
        return Files.getLastModifiedTime(path);
    }

    private Path sqlFileName(String database, String context) {
        final String sqlFile = this.sqlFileNameFormat
            .replace("@{group}", context)
            .replace("@{database}", database)
            .replace("@{service}", this.serviceName)
            .replace('/', File.separatorChar);

        return getScriptsDirectory().toPath().resolve(sqlFile);
    }

    protected abstract File getScriptsDirectory();

    private Writer createWriter(Path path) throws IOException {
        getLog().info(format("Creating %s", relativePath(path)));

        Files.createDirectories(path.getParent());

        return new OutputStreamWriter(this.buildContext.newFileOutputStream(path.toFile()), this.encoding);
    }

    private Path relativePath(Path path) {
        return this.project.getBasedir().toPath().relativize(path);
    }

    private File cacheFile(String name) {
        final Path output = relativePath(getScriptsDirectory().toPath());
        final int nameCount = output.getNameCount();
        final Path relPath = nameCount < 2
            ? output
            : output.getName(nameCount - 2).resolve(output.getName(nameCount - 1));
        return this.cacheDirectory.toPath().resolve(relPath).resolve(name).toFile();
    }
}
